import { useState, useEffect } from 'react';
import { createClient } from '@/lib/supabase/client';
import { LoyaltyCard, LoyaltyTransactionType } from '../types';
import { useAuth } from '@/features/auth/context/AuthContext';
import { canUser } from '@/config/plans';

export function useLoyalty(barbershopId: string) {
    const { userProfile } = useAuth();
    const [card, setCard] = useState<LoyaltyCard | null>(null);
    const [loading, setLoading] = useState(false);
    const supabase = createClient();

    const plan = userProfile?.plan || 'FREE';
    // Use 'loyalty' feature key
    const hasPermission = canUser(plan, 'loyalty');

    const fetchCard = async () => {
        if (!userProfile?.uid || !barbershopId) return;

        // Permission Check
        if (!hasPermission) {
            setLoading(false);
            return;
        }

        try {
            setLoading(true);
            const { data, error } = await supabase
                .from('loyalty_cards')
                .select('*')
                .eq('user_id', userProfile.uid)
                .eq('barbershop_id', barbershopId) // Assuming snake_case
                .single();

            if (data) {
                // Map snake_case to camelCase
                const mappedCard = {
                    ...data,
                    userId: data.user_id,
                    barbershopId: data.barbershop_id,
                    totalEarned: data.total_earned,
                    lastUpdated: new Date(data.last_updated), // ISO string to Date
                    transactions: data.transactions || []
                }
                setCard(mappedCard as LoyaltyCard);
            } else {
                setCard(null);
            }
        } catch (error) {
            console.error("Error fetching loyalty card:", error);
        } finally {
            setLoading(false);
        }
    };

    const addPoints = async (points: number, description: string) => {
        if (!hasPermission) throw new Error("Upgrade needed for Loyalty features");
        if (!userProfile?.uid || !barbershopId) return;

        const transactionId = crypto.randomUUID();
        const newTransaction = {
            id: transactionId,
            date: new Date().toISOString(),
            type: 'EARN' as LoyaltyTransactionType,
            points,
            description
        };

        try {
            if (card) {
                // Update existing card
                // Postgrest doesn't have native atomic 'increment' in client UPDATE.
                // We should use an RPC (Stored Procedure) for safety or read-modify-write (optimistic but risky for concurrency).
                // Or simplified: fetch fresh, then update.
                // Since this is a simple app, we'll fetch current balance via the previous 'card' state or fresh fetch?
                // Using current 'card' state is "optimistic".

                // Better approach with JSONB array: append.

                const newBalance = (card.balance || 0) + points;
                const newTotal = (card.totalEarned || 0) + points;
                const newTransactions = [...(card.transactions || []), newTransaction];

                const { error } = await supabase
                    .from('loyalty_cards')
                    .update({
                        balance: newBalance,
                        total_earned: newTotal,
                        last_updated: new Date().toISOString(),
                        transactions: newTransactions // Replacing array: concurrency risk if not careful, but okay for MVP
                    })
                    .eq('id', card.id);

                if (error) throw error;
            } else {
                // Create new card
                const newCardData = {
                    user_id: userProfile.uid,
                    barbershop_id: barbershopId,
                    balance: points,
                    total_earned: points,
                    last_updated: new Date().toISOString(),
                    transactions: [newTransaction]
                };

                // Assuming 'id' is autogenerated or we can provide composite key if Table uses it.
                // Let's assume auto-id.

                const { error } = await supabase
                    .from('loyalty_cards')
                    .insert([newCardData]);

                if (error) throw error;
            }
            fetchCard(); // Refresh local state
        } catch (error) {
            console.error("Error adding loyalty points:", error);
            throw error;
        }
    };

    const redeemReward = async (cost: number, rewardName: string) => {
        if (!hasPermission) throw new Error("Upgrade needed");
        if (!card || card.balance < cost) throw new Error("Saldo insuficiente");

        const transactionId = crypto.randomUUID();
        const newTransaction = {
            id: transactionId,
            date: new Date().toISOString(),
            type: 'REDEEM' as LoyaltyTransactionType,
            points: -cost,
            description: `Resgate: ${rewardName}`
        };

        try {
            const newBalance = card.balance - cost;
            const newTransactions = [...(card.transactions || []), newTransaction];

            const { error } = await supabase
                .from('loyalty_cards')
                .update({
                    balance: newBalance,
                    last_updated: new Date().toISOString(),
                    transactions: newTransactions
                })
                .eq('id', card.id);

            if (error) throw error;
            fetchCard();
        } catch (error) {
            console.error("Error redeeming reward:", error);
            throw error;
        }
    };

    useEffect(() => {
        fetchCard();
    }, [userProfile, barbershopId]);

    return {
        card,
        loading,
        addPoints,
        redeemReward,
        refresh: fetchCard,
        hasPermission
    };
}
